
#include <iostream>

#include "pushPacketId.hh"
using namespace std;

void testPushPacketId() {
	uint32_t totalGood = 0;
	uint32_t totalBad = 0;

	cout << "-------------------------------------------------------------------" << endl;
	cout << "Start testing PushPacketId element..." << endl;

	PushPacketId ppid (3);

	for (uint32_t seqNum = 0; seqNum <= 268435455; seqNum ++) {
		uint16_t te1 = seqNum >> 7;

		if (((te1 & 4095) == 4095) || ((te1 & 4095) == 0)) {
			if (!ppid.isValidSeqNum(seqNum)) {
//				cout << "[" << total++ << "] seqNum " << seqNum << " (te1: " << te1 << ") is invalid !!" << endl;
			} else {
				cout << "There is a difference for seqNum: " << seqNum << endl;
			}
			totalBad++;
		} else {
			uint32_t generatedSeq = ppid.getNexSeqNum();
			if (seqNum != generatedSeq) {
				cout << "Difference: seqNum: " << seqNum << ", generatedSeq: " << generatedSeq << endl;
			}
			totalGood++;
		}
	}

	if (totalGood != 268304384) {
		cout << "There is a difference in total good sequence numbers (" << totalGood << ") instead of 268304384" << endl;
	}

	if (totalBad != 131072) {
		cout << "There is a difference in total bad sequence numbers (" << totalBad << ") instead of 131072" << endl;
	}

	if (ppid.createId() != 25769807873) {
		cout << "ERROR: Expected: unified id: 25769807873, seqNum: 128, inner: 1536, middle: 1, outer: 1\n" << endl;
	}

	if (ppid.createId() != 25769807905) {
		cout << "ERROR: Expected: unified id: 25769807905, seqNum: 129, inner: 1536, middle: 1, outer: 33\n" << endl;
	}

	for (int i=0; i<126; i++) {
		ppid.getNexSeqNum();
	}

	if (ppid.createId() != 25769811969) {
		cout << "ERROR: Expected: unified id: 25769811969, seqNum: 256, inner: 1536, middle: 2, outer: 1\n" << endl;
	}


	cout << "Done testing." << endl;
}

int main() {
	cout << "!!!Hello World1!!!" << endl;
	uint16_t tci1, tci2, tci3;
	tci1 = 49;		// least significant
	tci2 = 4003;
	tci3 = 204;		// most significant [inner encap]

	uint64_t result = tci3;
	result = (result << 12) | tci2;
	result = (result << 12) | tci1;

	cout << "tci1: " << tci1 << ", tci2: " << tci2 << ", tci3: " << tci3 << ", res: " << result << endl;

	uint16_t version = tci1 & 31;	// the version number is the right-most 5 bits. In order to avoid tci1 to be 4095, we permit achieving only 31 versions (0-30). version 31 is prohibited.
	cout << "the version is: " << version << endl;
	uint16_t newVersion = version + 1;
	cout << "the new version is: " << newVersion << endl;


	testPushPacketId();

	return 0;
}


//bool isValidSeqNum(uint32_t candidate) {
//	// we want to ignore the three right-most bits (because they part of the inner vlan and
//	// therefore valid (no chance to get 0 or 4095 thanks for the version bits).
//	candidate = candidate >> 3;
//
//	// then we want to check the 12 bits that constitute the second vlan (4095 = 111111111111).
//	candidate &= 4095;
//
//	// finally we check that the middle vlan isn't 0 or 4095 (preserved for 802.1Q).
//	if (candidate == 4095 || candidate == 0) {
//		return false;
//	}
//
//	return true;
//}

/*
 * There is IDProducer instance before the first middlebox in each chain and after each
 * middlebox that change the packet content (whether it's the packet header or the packet
 * payload). The IDProducer instance is independent of the middlebox logic.
 * IDProducerI:
 * 	- void init(int id): set unique id for the id producer instance (which will be
 * 		prefix for all ids generated by this instance).
 * 	- bool hasID(packet): returns true if an id was added to this packet by some id producer
 * 	- int generateId: generate a new id, based on the instance uniqueId.
 * 	- void incrementAndSetId(packet): add 1 to the id and update the packet id.
 *
 *-------------------------------------------------------------------------------------------
 *
 * There is one WrappedPacketsLoggerManager for each wrapped packets logger. In case of
 * centralized logger, one manager instance will be created.
 * WrappedPacketsLoggerManager:
 * 	- void init(int wplmId): set the wrapped packet logger manager id.
 * 	- bool save(int packetId, WPLRecord wplRecord): save the received wplRecord (the value) to the log for
 * 											  the received packet id (the key). Returns true
 * 											  upon success.
 * 	- WPLRecord load(int packetId): load the wplRecord that was saved for the received packet id.
 * 								 Returns null upon failure.
 *
 *-------------------------------------------------------------------------------------------
 *
 *	There is one client for each middlebox that change the packet content (whether the header or
 *	the payload) and before the first middlebox in each chain. The client will be responsible
 *	to communicate with wrappedPacketsLoggerManager.
 * 	WrappedPacketsLoggerClient:
 * 		- void init(int id, ConnectionInfo managerConnectionInfo, int saveFromByte,
 * 					int saveToByte): init the client with the following data:
 * 						# id - This method creates an IDProducer instance and set the received
 * 							   id as an IDProducer id.
 * 						# managerConnectionInfo - it contains all the data relevant for
 * 												  communicating with the appropriate
 * 												  WrappedPacketsLoggerManager (for example: ip
 * 												  address, port num, etc.).
 * 						# saveFromByte, saveToByte - all the bytes in
 * 													 range [saveFromByte, saveToByte] should be
 * 													 saved (related to the middlebox that change
 * 													 them). In case that the client stands before
 * 													 the first middlebox (the first entity in
 * 													 the chain) it expects to receive 0,MAX_INT.
 * 		- WPLRecord generateWPLRecord(String packet): generate wplRecord from the received packet by
 * 												taking into account saveFromByte and saveToByte.
 * 		- bool saveWPLRecord (int packetId, WPLRecord wplRecord): save the wplRecord by using
 * 													 managerConnectionInfo. Returns true upon
 * 													 success.
 * 		- bool savePacket(String packet): generate a new id for the packet (set a new one or
 * 										  increase the existing one by 1), generateWPLRecord and
 * 										  then call to saveWPLRecord(packetId, wplRecord).
 * 										  Returns true upon success.
 * 		- WPLRecord loadWPLRecord(int packetId): returns the *wplRecord* associated to the received
 * 										   packetId. The wplRecord contains only the diff to the
 * 										   previous packet version.
 * 		- Packet loadPacket(int packetId): returns the *packet* associated to the received
 * 										   packetId (by building it iteratively). It returns null
 * 										   in case of a failure.
 *
 *-------------------------------------------------------------------------------------------
 *
 *	Represents a wrapped packet logger record to be stored in the wrapped packets logger.
 *	WPLRecord:
 *		- int getFromByte(): returns the first byte number that is changed *in the previous*
 *							 version.
 *		- int getToByte(): returns the last byte number that is changed *in the previous* version.
 *		- String getContent(): returns the changed content. Note that the size of the received
 *							   string may be differ than getToByte()-getFromByte() (for example by
 *							   replacing 6 characters with 4 characters).
 *
 *-------------------------------------------------------------------------------------------
 *
 *	There is one DetLoggerManager for each determinants logger. In case of centralized logger,
 *	one manager instance will be created.
 *	DetLoggerManager:
 *		- void init(int dtmId): set the determinant logger manager id.
 *		- bool save(EPAL epal): save the received extended PAL (the value) to the log. Returns
 *								true upon success.
 *		- Map<packetId, list<EPAL>> getDeterminantsForMBId(int middleboxId): returns a map
 *			between all the existing packet ids in the log to a list of all of their EPALs.
 *			It returns null in case of an error.
 *		- list<packetId> getAllStoredPacketIds(): returns a list of all the stored packet ids.
 *												  Basically the manager should keep in his RAM
 *												  all the available stored packet ids (in case
 *												  of a manager failure only the first call to
 *												  this method will take time).
 *
 *-------------------------------------------------------------------------------------------
 *-------------------------------------------------------------------------------------------
 *
 *	EPAL (Extended PAL):
 *		- constructors, getters and setters
 *
 *-------------------------------------------------------------------------------------------
 *-------------------------------------------------------------------------------------------
 *
 *	FtManager:
 *		- bool registerMB(clientConnInfo cci, int mbId, bool mbMasterState, int siblingMbId):
 *		  	registers mbId to the service. cci holds the ip address and port that the middlebox
 *		  	will listen for new state changes. In case that the registered middlebox is master
 *		  	mbMasterState will be true (false otherwise). siblingMbId is the id of the
 *		  	master/slave of the registered middlebox (mbId).
 *			The function returns true upon success.
 *
 *		- short getPrefixForFirstLevelIDProducer(int mbId):
 *			The function returns sequence number (of range [0,67]) which will be the prefix of
 *			all ids that will be generated by this first-level ID Producer.
 *			Note: each id of a packet will be consisted of 3 vlan id levels (which generates
 *			4094^3 = 68,618,862,584 ids). the two left-most digits will be the returned
 *			sequence number. the three right-most digits will be used for packet
 *			version (starting from 000). Therefore, each first-level ID Producer can generate
 *			999,999 different packets without the need of cleanup process.
 *
 *		- bool recover(mbId):
 *			change the state of siblingMbId to be the master, and bring him to the same state
 *			as mbId before the crashing. It also need to change the flows s.t. it goes
 *			through siblingMbId instead of mbId. In addition it needs to create a new slave.
 *			The function returns true upon success.
 *
 *		- bool
 *
 *-------------------------------------------------------------------------------------------
 *-------------------------------------------------------------------------------------------
 *
 *	Core Click elements to be updated:
 *		- I need to search click_random() usage (or other "rand" function) and change them s.t.
 *		  I'll store their return value in det logger. In addition I need to add to these
 *		  elements a new argument option called 'slaveMode' (default is false). This will allow
 *		  me to decide whether to call rand() or ask the value from the det. logger.
 *
 *		- toDevice element: I need to update it s.t it will send an event to the slave and then
 *		  to progressLogger.
 *
 *		- for MazuNat:
 *		  tcprewriter / iprewriter / iprewriterbase (DetLoggers)
 *
 *	New Click Elements:
 *		- ID producer:
 *			This element will be called for both the first id producer in the chain and for the
 *			following id producers in the chain. I need to better define it (maybe I don't need
 *			to call this element for the second id producer but just update
 *			tcprewriter / iprewriter / iprewriterbase to do so).
 *
 *	Open Issues:
 *		- How to switch between master and slave click configure files (for the fast recovery)?
 *		- How to add an id for each packet? two-levels of vlan?
 *		- Use ID Producer for second member or change tcprewriter / iprewriter / iprewriterbase?
 *		- Define ID Producer element (according to the point above).
 *			(http://read.cs.ucla.edu/click/doxygen/classPacket.html)
 *		- Which middleboxes should we use (MazuNat, etc.)?
 *
 *-------------------------------------------------------------------------------------------
 */
